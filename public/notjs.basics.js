// Generated by CoffeeScript 1.4.0
(function() {
  var Notjs, ROOT_NAMESPACE,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  ROOT_NAMESPACE = typeof module !== 'undefined' && module.exports ? global : window;

  Notjs = (function() {
    var _this = this;

    function Notjs() {
      this.globalNamespace = __bind(this.globalNamespace, this);

    }

    /*
        This is the top level Notjs class
    
        One instance per application use is instantiated and added to the global namespace
    */


    Notjs.prototype.namespace = function(target, name, block) {
      /*
            this method is used to create a namespace for Notjs.
            See (https://github.com/jashkenas/coffee-script/wiki/FAQ)
            MODIFIED!  - if we are using namespaces let's let everything work the same in node and just add our
                    namespace to global namespace
      */

      var item, top, _i, _len, _ref, _ref1;
      if (arguments.length < 3) {
        _ref = [this].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
      }
      top = target;
      _ref1 = name.split('.');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        item = _ref1[_i];
        target = target[item] || (target[item] = {});
      }
      return block(target, top);
    };

    Notjs.prototype.globalNamespace = function() {
      /*
            returns the object representing the global namespace (window in browser and global in node.js
      */
      return ROOT_NAMESPACE;
    };

    Notjs.prototype.addPrototypeUnlessExists = function(klass, protoName, method) {
      /*
            convenience method for adding a prototype to a class if it doesn't exist.   Useful for things
            like adding methods to String and Array that another library may have already loaded.
      
            example:
            |  Notjs.addPrototypeUnlessExists(String, 'startsWith', function('str'){
            |    this.slice(0, str.length) == str;
            |  });
      */

      var proto;
      proto = klass.prototype[protoName] || (klass.prototype[protoName] = method);
      return proto;
    };

    Notjs.prototype.errors = {
      pureVirtualMissing: function(className, methodName) {
        throw "" + className + " pure virtual method " + methodName + " missing. Must override in subclass of FormInput.";
      },
      invalidArgument: function(argumentName) {
        throw "Invalid Argument: " + argumentName;
      },
      selectorNotFound: function(selector) {
        throw "Notjs:  selector not found " + (selector.toString());
      }
    };

    return Notjs;

  }).call(this);

  ROOT_NAMESPACE.Notjs = new Notjs();

}).call(this);


// Generated by CoffeeScript 1.4.0

/*
  javascript Array class extensions and monkeys
*/


(function() {

  Notjs.addPrototypeUnlessExists(Array, "remove", function(from, to) {
    /*
        removes an element from an array
    
        by John Resig (MIT Licensed) (http://ejohn.org/blog/javascript-array-remove/)
    */

    var rest;
    rest = this.slice((to || from) + 1 || this.length);
    this.length = from < 0 ? this.length + from : from;
    return this.push.apply(this, rest);
  });

  Notjs.addPrototypeUnlessExists(Array, "englishJoin", function() {
    /*
        returns a string of items separated by comma except the last which is prefaced by "and"
    */

    var lastComma, out;
    out = this.join(',');
    lastComma = out.lastIndexOf(',');
    if (lastComma <= 0) {
      return out;
    }
    return out.slice(0, +(lastComma - 1) + 1 || 9e9) + ' and ' + out.slice(lastComma + 1);
  });

}).call(this);


// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Notjs.namespace('basics', function(x) {
    return x.Form = (function() {
      /*
          The Notjs.basics.Form class is instantiated on a DOM element identifying the container
          of FormInput elements that will be used to display and take input.  The constructor
          parameter <i>@selector</i> identifies the DOM element and the <i>dataObject</i> parameter
          has a javascript object that is bound to this form.  Each FormInput identified by a 
          data-not_attr attribute represents an attribute within <i>dataObject</id>
      
          Depending on the formMode option to the constructor, the data displayed in the form
          and the input data collected from the user are saved in a Javascript object called
          <i>dataObject</i> passed to the constructor.  There is also provision for notification
          of updates via an optional callback function (updateCallback).
      
          Note that forms do not need to be in &lt;form&gt; tags.  The example below demonstrates
          a form constructed in a div.  If you do construct the notjs Form on a form tag, it
          will disable the form from posting back to the server and then update <i>dataObject</i> and
          call updateCallback.
      
          Simplest Example:
            <code>
            |  <html>
            |    <body>
            |      <div id="authorEditForm">
            |        <div data-not_attr="name"></div>
            |        <div data-not_attr="genre"></div>
            |        <div class='readonly' data-not_attr="modifiedAt"></div>
            |        <button class="success">Save it!</button><button class="cancel">Nevermind</button>
            |      </div>
            |    </body>
            |  </html>
            |  <script>
            |    var dataObject = {name: "Arthur C. Clark", genre: "science fiction", modifiedAt: "6/15/2012"};
            |    var form = new Notjs.basics.Form("#authorEditForm", dataObject, {
            |        updateCallback: function(whatUpdated){ alert("You updated " + whatUpdated + ". I'm telling");}
            |    });
            </code>
      
          Produces this:
            <code>
            |  <html>
            |    <body>
            |      <div id="authorEditForm">
            |        <div data-not_attr="name"><input type="text" value="Arthur C. Clark"></div>
            |        <div data-not_attr="genre"><input type="text" value="science fiction"></div>
            |        <div class='readonly' data-not_attr="modifiedAt">6/15/2012</div>
            |        <button class="success">Save it!</button><button class="cancel">Nevermind</button>
            |      </div>
            |    </body>
            |  </html>
            </code>
      
          Each element that identifies a FormInput object must, at a minimum, have
          a data-not_attr attribute that identifies where in the <i>dataObject</i> the value for
          this input lives.
      
          Another often needed attribute is the data-not_type which is defaulted to "Text".
          <code>
           | <div data-not_attr="wonHugoAward" data-not_type="Checkbox"></div>
          </code>
          The example above would create a Notjs.basics.formInputs.Checkbox type that would
          display and allow input, as a checkbox.  By default the namespace to that class is
          Notjs.basics.formInputs.  You call also specify a fully namespaced class, e.g.
          <code>
           |  <div data-not_attr="wonHugoAward" data-not_type="Slick.Editors.Text"></div>
          </code>
          ... yes, you can!  Notjs FormInputs steal their creation mechanics and API from SlickGrid
          and are designed to be interchangable.
      
          CSS class interactions:
            - "readonly"  # no input will be made available regardless of all other options and settings. this
                          # css class can be used on either form element or the individual data-not_attr form 
                          # input elements.
            - "hidden"    # added to submit / success buttons on form without any FormInputs in input mode
            - "success"   # any element in the form with this class will be assumed clickable and mean save
            - "cancel"    # any element in the form with this class will be assumed clickable and mean cancel edit
      
      
          HTML5 data attributes and defaults:
            - data-not_attr=""      # the name of the data or method attribute on <i>dataObject</i>
            - data-not_type="Text"  # the FormInput class name to create.
      
          Note the this class, Notjs.basics.Form, handles switching the FormInputs between display and input mode
          and navigation between inputs with the keyboard and mouse.
      */

      function Form(selector, dataObject, options) {
        this.selector = selector;
        this.dataObject = dataObject;
        if (options == null) {
          options = {};
        }
        this._cancelChanges = __bind(this._cancelChanges, this);

        this._commitChanges = __bind(this._commitChanges, this);

        this._getClassFor = __bind(this._getClassFor, this);

        this._defaultCancelCallback = __bind(this._defaultCancelCallback, this);

        this._defaultUpdateCallback = __bind(this._defaultUpdateCallback, this);

        this._startInlineEdit = __bind(this._startInlineEdit, this);

        this._findCancelButtons = __bind(this._findCancelButtons, this);

        this._findSaveButtons = __bind(this._findSaveButtons, this);

        this._focusOnCancel = __bind(this._focusOnCancel, this);

        this._focusOnSave = __bind(this._focusOnSave, this);

        this._hideSaveAndCancel = __bind(this._hideSaveAndCancel, this);

        this._showSaveAndCancel = __bind(this._showSaveAndCancel, this);

        this._initializeSaveAndCancel = __bind(this._initializeSaveAndCancel, this);

        this._destroyFormInputObject = __bind(this._destroyFormInputObject, this);

        this._displayDataFor = __bind(this._displayDataFor, this);

        this._displayDataForAll = __bind(this._displayDataForAll, this);

        this._instantiateFormInputFor = __bind(this._instantiateFormInputFor, this);

        this._showInputFor = __bind(this._showInputFor, this);

        this._showAllInputs = __bind(this._showAllInputs, this);

        this._switchToFullInput = __bind(this._switchToFullInput, this);

        this._editOnClick = __bind(this._editOnClick, this);

        this._removeClickHandlers = __bind(this._removeClickHandlers, this);

        this._installClickHandlers = __bind(this._installClickHandlers, this);

        this._initializeFormInputs = __bind(this._initializeFormInputs, this);

        this.setFormMode = __bind(this.setFormMode, this);

        this.refresh = __bind(this.refresh, this);

        this.initialize = __bind(this.initialize, this);

        this.options = _.defaults(options, {
          formMode: "fullInput",
          updateCallback: this._defaultUpdateCallback,
          cancelCallback: this._defaultCancelCallback
        });
        /*
              Constructs a new Form object
        
              selector = css selector of DOM element containing formInputs
              dataObject = data object (hash) to get and set values on
        
              The formMode constructor option supports several options that govern how the form
              will accept input and when the associated dataObject is updated and updateCallback
              is called.
        
                <b>formMode: "fullInput"</b> - (default) Form will look and feel like a classic
                  web form with all inputs turned on.  <b>The form must have either a clickable element
                  with the css class 'success' or a traditional &lt;input type="submit"&gt;.</b>
        
                  All clickable elements within the selector DOM with the class "success" will be
                  overtaken (preventDefault and no propagation) by this instance of Form.
        
                  dataObject is updated and updateCallback is called when a ".success" element is
                  clicked.
        
                <b>formMode: "inlineEdit"</b> - form will display data from dataObject
                  and when the user clicks on the displayed data, it will switch to input mode.
                  dataObject attribute associated with the single input that was taken is updated
                  and updateCallback method is called with the attribute name updated.
        
                <b>formMode: "fullInputOnClick"</b> - form inputs will initially be all display
                  only and when any element in the form is clicked, the whole form becomes editable.
                  The form must provide a submit button which is hidden until the user clicks
                  to edit form.  Hidding of the button is provided by the addition and removal
                  of the .hidden css class.
        
                <b>formMode: "readOnly"</b> - Form will only display data.
        
              Individual form input DOM elements can additionally declare themselves to be read only
              by including the css class "readonly".  See modifiedAt in the above example.
        
              See also:   Notjs.basics.FormInput class
        */

        this.formInputs = [];
        return this.initialize();
      }

      Form.prototype.initialize = function() {
        /*
              The initialize() method looks in the DOM under the selector passed to the constructor
              for any elements with the data-not_attr attribute set and instantiates a
              Notjs.basics.FormInput object for element found.
        */
        this.$element = $(this.selector);
        if (this.$element.length <= 0) {
          Notjs.errors.selectorNotFound(this.selector);
        }
        this._initializeFormInputs();
        this._initializeSaveAndCancel();
        this.setFormMode(this.options.formMode);
        return this;
      };

      Form.prototype.refresh = function() {
        return this.setFormMode(this.options.formMode);
      };

      Form.prototype.setFormMode = function(mode) {
        if (this.$element.hasClass('readonly')) {
          mode = "readOnly";
        }
        this.options.formMode = mode;
        this.inlineEditing = false;
        this.switchedToFullInput = false;
        switch (mode) {
          case "fullInput":
            this._removeClickHandlers();
            this._showAllInputs();
            return this._showSaveAndCancel();
          case "inlineEdit":
          case "fullInputOnClick":
            this._displayDataForAll();
            this._installClickHandlers();
            return this._hideSaveAndCancel();
          case "readOnly":
            this._displayDataForAll();
            this._removeClickHandlers();
            return this._hideSaveAndCancel();
          default:
            return Notjs.errors.invalidArgument("formMode");
        }
      };

      Form.prototype._initializeFormInputs = function() {
        var $element, element, type, _i, _len, _ref, _results;
        this.formInputs = [];
        _ref = this.$element.find('[data-not_attr]');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          element = _ref[_i];
          $element = $(element);
          type = $element.data('not_type') || "Text";
          _results.push(this.formInputs.push({
            $element: $element,
            type: type,
            attr: $element.data('not_attr'),
            formInputClass: this._getClassFor(type),
            formInputObject: null
          }));
        }
        return _results;
      };

      Form.prototype._installClickHandlers = function() {
        var _this = this;
        return _.each(this.formInputs, function(formInput) {
          return formInput.$element.on('mouseup.notjs-form', function() {
            return _this._editOnClick(formInput);
          });
        });
      };

      Form.prototype._removeClickHandlers = function() {
        var formInput, _i, _len, _ref, _results;
        _ref = this.formInputs;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          formInput = _ref[_i];
          _results.push(formInput.$element.off('mouseup.notjs-form'));
        }
        return _results;
      };

      Form.prototype._editOnClick = function(formInput) {
        if (this.options.formMode === "fullInputOnClick") {
          return this._switchToFullInput();
        } else {
          return this._startInlineEdit(formInput);
        }
      };

      Form.prototype._switchToFullInput = function() {
        if (this.switchedToFullInput) {
          return;
        }
        this.switchedToFullInput = true;
        this._showAllInputs();
        return this._showSaveAndCancel();
      };

      Form.prototype._showAllInputs = function() {
        var formInput, _i, _len, _ref, _results;
        _ref = this.formInputs;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          formInput = _ref[_i];
          _results.push(this._showInputFor(formInput));
        }
        return _results;
      };

      Form.prototype._showInputFor = function(formInput) {
        if (formInput.$element.hasClass('readonly')) {
          return this._displayDataFor(formInput);
        } else {
          if (!formInput.formInputObject) {
            formInput.$element.html("");
            formInput.formInputObject = this._instantiateFormInputFor(formInput);
          }
          return formInput.formInputObject.loadValue(this.dataObject);
        }
      };

      Form.prototype._instantiateFormInputFor = function(formInput) {
        var args;
        args = {
          container: formInput.$element,
          column: {
            field: formInput.attr
          },
          grid: this,
          gridPosition: 0,
          position: 0,
          item: this.dataObject,
          cancelChanges: this._cancelChanges,
          commitChanges: this._commitChanges
        };
        return new formInput.formInputClass(args);
      };

      Form.prototype._displayDataForAll = function() {
        var formInput, _i, _len, _ref, _results;
        _ref = this.formInputs;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          formInput = _ref[_i];
          _results.push(this._displayDataFor(formInput));
        }
        return _results;
      };

      Form.prototype._displayDataFor = function(formInput) {
        var $el, attr, klass;
        $el = formInput.$element;
        klass = formInput.formInputClass;
        attr = formInput.attr;
        if (!((klass.formatForDisplay != null) && _.isFunction(klass.formatForDisplay))) {
          console.warn(("FormInput type " + formInput.type + " for " + attr + " doesn't have a ") + "formatForDisplay class method. skipping");
          return;
        }
        this._destroyFormInputObject(formInput);
        return $el.html(klass.formatForDisplay($el, $el, this.dataObject[attr], null, this.dataObject));
      };

      Form.prototype._destroyFormInputObject = function(formInput) {
        if (formInput.formInputObject) {
          formInput.formInputObject.destroy();
          return formInput.formInputObject = null;
        }
      };

      Form.prototype._initializeSaveAndCancel = function() {
        this._findSaveButtons().on('click.notjsForm', this._commitChanges);
        return this._findCancelButtons().on('click.notjsForm', this._cancelChanges);
      };

      Form.prototype._showSaveAndCancel = function() {
        this._findSaveButtons().delay(0).fadeIn();
        return this._findCancelButtons().delay(0).fadeIn();
      };

      Form.prototype._hideSaveAndCancel = function() {
        this._findSaveButtons().delay(0).fadeOut();
        return this._findCancelButtons().delay(0).fadeOut();
      };

      Form.prototype._focusOnSave = function() {
        return this._findSaveButtons().first().focus();
      };

      Form.prototype._focusOnCancel = function() {
        return this._findCancelButtons().first().focus();
      };

      Form.prototype._findSaveButtons = function() {
        return this.$element.find("input[type='submit'], .success");
      };

      Form.prototype._findCancelButtons = function() {
        return this.$element.find(".cancel");
      };

      Form.prototype._startInlineEdit = function(formInput) {
        if (formInput.$element.hasClass('readonly')) {
          return;
        }
        if (formInput === this.inlineEditing) {
          return;
        }
        if (this.inlineEditing) {
          this._commitChanges();
        }
        this._showInputFor(formInput);
        this._showSaveAndCancel();
        return this.inlineEditing = formInput;
      };

      Form.prototype._defaultUpdateCallback = function() {};

      Form.prototype._defaultCancelCallback = function() {};

      Form.prototype._getClassFor = function(type) {
        var current, part, _i, _len, _ref;
        if (Notjs.basics.formInputs[type]) {
          return Notjs.basics.formInputs[type];
        }
        current = Notjs.globalNamespace();
        _ref = type.split('.');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          if (current[part]) {
            current = current[part];
          } else {
            throw "Unable to find class for FormInput type " + type + ", specifically " + part;
          }
        }
        return current;
      };

      Form.prototype._commitChanges = function() {
        var formInput, formInputs, whatChanged, _i, _len;
        if (this.inlineEditing) {
          formInputs = [this.inlineEditing];
          this.inlineEditing = false;
        } else {
          formInputs = this.formInputs;
        }
        whatChanged = [];
        for (_i = 0, _len = formInputs.length; _i < _len; _i++) {
          formInput = formInputs[_i];
          if (formInput.formInputObject == null) {
            continue;
          }
          formInput.formInputObject.applyValue(this.dataObject, formInput.formInputObject.serializeValue());
          whatChanged.push(formInput.attr);
        }
        _.defer(this._focusOnSave);
        this.options.updateCallback(whatChanged);
        return this.refresh();
      };

      Form.prototype._cancelChanges = function() {
        this.inlineEditing = false;
        this.refresh();
        this._focusOnCancel();
        return this.options.cancelCallback();
      };

      return Form;

    })();
  });

}).call(this);


// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Notjs.namespace('basics', function(x) {
    return x.FormInput = (function() {
      /*
          The FormInput class is an abstract base class for all form input types.
      
          A specific type of FormInput is instantiated on a DOM element identifying a
          container.  The value of the DOM element ($().html()) is then after controlled
          by the FormInput type.   An outside party (Notjs.basics.Form or Slick.Grid)
          tells the type when to display data by calling the formatForDisplay() class
          method; and it also tells the FormInput type when to render html capable of
          taking user input.
      
          The FormInput classes provide an interface compatible to that of SlickGrid's
          Editor extentions and are intended to be used interchangably in that environment.
      
          See <a href="https://github.com/mleibman/SlickGrid/wiki/Writing-custom-cell-editors">SlickGrid: Writing custom cell editors</a> for more information.
      
          The Form base class defined here provides defaults  for some of the methods required by
          SlickGrid editors.   At a minimum, any extension of this class must provide the following methods:
      
            - a static class method called formatForDisplay (which can be used as SlickGrid
                formatter) which returns a string containing the html to render in the
                formInput element
            - an instance method called initialize() called on construction that creates the input
            - an instance method called loadValue(dataObject) that sets the current value of the
                input to the value of it's corresponding attribute in dataObject
            - an instance method called serializeValue() that returns the current value of the input
      
          See Notjs.basics.formInputs.Text for a simple example of creating a custom editor / formatter that can be
          used with either Notjs.basics.Form or Slick.Grid.
      
          In most use cases, Notjs.basics.FormInputs and children are only instantiated by either Notjs.basics.Form
          or SlickGrid.  Application code should rarely need to create an indivual FormInput.  See documentation
          for Notjs.basics.Form for an example of how the are used there.
      */

      FormInput.formatForDisplay = function(row, cell, value, columnDef, dataContext) {
        /*
                This is class method that gets called when the data needs to be displayed in the container element
                without allowing user input
        */
        return Notjs.errors.pureVirtualMissing("FormInput", "@formatForDisplay");
      };

      function FormInput(args) {
        var $input;
        this.args = args;
        this.bindStandardKeys = __bind(this.bindStandardKeys, this);

        this.setDataObjectValue = __bind(this.setDataObjectValue, this);

        this.getDataObjectValue = __bind(this.getDataObjectValue, this);

        this.focus = __bind(this.focus, this);

        this.destroy = __bind(this.destroy, this);

        this.applyValue = __bind(this.applyValue, this);

        this.serializeValue = __bind(this.serializeValue, this);

        this.loadValue = __bind(this.loadValue, this);

        this.initialize = __bind(this.initialize, this);

        this.$element = this.args.container;
        this.attr = this.args.column.field;
        this.options = this.args.column;
        /*
              Constructs a new FormInput object
        
              element = css selector of DOM element where input will be rendered
              attr = attribute in "item" parameter on call to loadValue or applyValue where data is read/written
        
              See also:   Notjs.basics.FormInput class
        */

        $input = this.initialize();
        this.bindStandardKeys($input);
        return $input;
      }

      FormInput.prototype.initialize = function() {
        /*
              Creates the dom elements within @$element that will take input from the user
        */
        return Notjs.errors.pureVirtualMissing("FormInput", "initialize");
      };

      FormInput.prototype.loadValue = function(dataObject) {
        /*
                displays or selects current value of the attribute associated with dataObject into
                the input element and update input UI
        */
        return Notjs.errors.pureVirtualMissing("FormInput", "loadValue");
      };

      FormInput.prototype.serializeValue = function() {
        /*
                returns the current value of user input
        */
        return Notjs.errors.pureVirtualMissing("FormInput", "serializeValue");
      };

      FormInput.prototype.applyValue = function(dataObject, value) {
        /*
                called to update the attribute in dataObject with the value passed
        */
        return this.setDataObjectValue(dataObject, value);
      };

      FormInput.prototype.destroy = function() {
        /*
                called when input is being removed from the DOM. remove all data, events & dom elements created in
                initialize
        */
        return this.$element.html("");
      };

      FormInput.prototype.focus = function() {
        /*
                should set focus to first input control if any
        */
        return this.$element.focus();
      };

      FormInput.prototype.getDataObjectValue = function(dataObject) {
        /*
                gets the value from the dataObject for the associated attribute
        */
        return Notjs.deepGet(dataObject, this.attr) || "";
      };

      FormInput.prototype.setDataObjectValue = function(dataObject, value) {
        /*
                does a deep set on the dataobject use data-not_attr as the property path
        */
        return Notjs.deepSet(dataObject, this.attr, value);
      };

      FormInput.prototype.bindStandardKeys = function($input) {
        /*
                Binds escape = cancelChanges
                      enter = commitChanges
        */

        var _this = this;
        return $input.on('keydown.notjsFormInput', function(e) {
          switch (e.keyCode) {
            case Notjs.keyCode.ENTER:
              return _this.args.commitChanges();
            case Notjs.keyCode.ESCAPE:
              return _this.args.cancelChanges();
          }
        });
      };

      return FormInput;

    }).call(this);
  });

}).call(this);


// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Notjs.namespace('basics', function(x) {
    return x.Partials = (function() {
      /*
          Partials are in page and external partial templates that are resolved and rendered into
          the page after the document is ready.  The placement of resolved partial in page is
          determined by a div with a data-not_partial attribute equal to DOM id of template or
          an external path.
      
          <b>In page partials</b>
      
            In page partials must have an element in the dom and the element must have an id.
            The inpage partial template element also must have the class "not-partial"
      
            Example:
            <code>
            |  <html>
            |    <body>
            |      <div id="authorTemplate" class="not-partial">
            |        <span class="name">Name</span><span class="genre">Genre</span>
            |      </div>
            |      Current Favorite Author:
            |      <div id="currentFavAuthor" class="favorite" data-not_partial="#authorTemplate"/>
            |      Authors List:
            |      <ul id='authorsList'>
            |        <li>
            |          <div data-not_partial="#authorTemplate"/>
            |        </li>
            |      </ul>
            |    </body>
            |  <html>
            |  <script>
            |    $(document).ready(function(){
            |      partials = new notjs.basics.Partials({removePartials: false, hidePartials: true})
            |      partials.resolve()
            |    });
            |  </script>
            </code>
            produces this:
            <code>
            |  <html>
            |    <body>
            |      <div id="authorTemplate" style="display: none;">
            |        <span class="name">Name</span><span class="genre">Genre</span>
            |      </div>
            |      Current Favorite Author:
            |      <div id="currentFavAuthor" class="favorite" data-not_partial="#authorTemplate">
            |        <span class="name">Name</span><span class="genre">Genre</span>
            |      </div>
            |      Authors List:
            |      <ul id='authorsList'>
            |        <li>
            |          <div data-not_partial="#authorTemplate"/>
            |            <span class="name">Name</span><span class="genre">Genre</span>
            |          </div>
            |        </li>
            |      </ul>
            |    </body>
            |  <html>
            </code>
      
          <b>External partials</b>
      
            External partials are fetched asynchronously from the server on resolve().  They are
            denoted from in page partials by the lack of a '#' prefix on the data-not_partial
            attribute.
      
            Example:
            <code>
            |  <html>
            |    <body>
            |      Current Favorite Author:
            |      <div id="currentFavAuthor" class="favorite" data-not_partial="/elements/authorTemplate.html"/>
            </code>
      
            The example above will do a get request type text/html to the server to get the
            html fragment that get's duplicated into the div with the data-not_partial attribute
      */

      Partials.resolve = function(options) {
        if (options == null) {
          options = {};
        }
        return new this(options).resolve();
        /*
                Class method for one shot convienence.  See .resolve instance method
        */

      };

      function Partials(options) {
        if (options == null) {
          options = {};
        }
        this.onPartialsResolved = __bind(this.onPartialsResolved, this);

        this.onPartialRendered = __bind(this.onPartialRendered, this);

        this.renderPartial = __bind(this.renderPartial, this);

        this.fetchExternalPartial = __bind(this.fetchExternalPartial, this);

        this.resolveExternal = __bind(this.resolveExternal, this);

        this.resolveInPage = __bind(this.resolveInPage, this);

        this.resolve = __bind(this.resolve, this);

        this.initialize = __bind(this.initialize, this);

        this.options = _.defaults(options, {
          removePartials: true,
          hidePartials: false,
          selector: 'body',
          onPartialsResolved: null,
          onPartialRendered: null
        });
        /*
                Constructs a new Partials object
        */

        this.inPagePartials = {};
        this.outstandingExternalRequests = 0;
        return this.initialize();
      }

      Partials.prototype.initialize = function() {
        var $partials;
        this.$el = $(this.options.selector);
        $partials = this.$el.find('.not-partial');
        this.inPagePartials = _.groupBy($partials, 'id');
        if (this.options.removePartials) {
          $partials.remove();
        }
        if (this.options.hidePartials) {
          $partials.hide();
        }
        return this;
      };

      Partials.prototype.resolve = function(options) {
        var _this = this;
        if (options == null) {
          options = {};
        }
        options = _.defaults(options, {
          onPartialsResolved: null
        });
        /*
                Replaces contents of divs with data-not_partial attribute with the html of the partial
                referenced in the data-not_partial attribute value.
        
                data-not_partial attribute may refer to an in page partial template denoted by a hash
                mark at the beginning of the attribute value
                <code>
                |  <div data-not_partial="#anotherElementId"/>
                </code>
                would mean that there is another div on the page with the id="anotherElementId" whose
                contents used.
        
                data-not_partial can also reference server sourced data.
                <code>
                |  <div data-not_partial="/someController/someElement.html"/>
                </code>
        
                Notes:
                  - any content within the data-not_partial element is replaced.
                  - external partials are retrieved asynchronously (as one might expect).  If you have
                    other client code depending on resolved partials you should use the
                    onPartialsResolved option to this method like this:
                    <code>
                    Notjs.basics.Partials.resolve({onPartialsResolved: function(){
                      Notjs.basics.Replicator.replicate('#moduleTemplate', documentorData, replicateModule)
                      Notjs.basics.Replicator.replicate('#apiDocs', documentorData, replicateModule)
                    }});
                    </code>
        */

        this.resolveExternal({
          onComplete: function() {
            _this.resolveInPage();
            return _this.onPartialsResolved(options.onPartialsResolved);
          }
        });
        return this;
      };

      Partials.prototype.resolveInPage = function() {
        var $place, $places, partial, partialElement, partialId, placeEl, _i, _len, _ref;
        $places = this.$el.find('[data-not_partial^="#"]');
        for (_i = 0, _len = $places.length; _i < _len; _i++) {
          placeEl = $places[_i];
          $place = $(placeEl);
          partial = $place.attr('data-not_partial');
          partialId = partial.slice(1);
          partialElement = (_ref = this.inPagePartials[partialId]) != null ? _ref[0] : void 0;
          if (partialElement) {
            this.renderPartial($place, $(partialElement).html());
          } else {
            console.error("In page partial not found by id " + partialId + " for element: ");
          }
        }
        return this;
      };

      Partials.prototype.resolveExternal = function(options) {
        var $place, $places, placeEl, uri, _i, _len;
        if (options == null) {
          options = {};
        }
        options = _.defaults(options, {
          onComplete: null
        });
        this.externalsRes;
        $places = this.$el.find('[data-not_partial*="/"]');
        if ($places.length <= 0) {
          if (typeof options.onComplete === "function") {
            options.onComplete();
          }
        }
        for (_i = 0, _len = $places.length; _i < _len; _i++) {
          placeEl = $places[_i];
          $place = $(placeEl);
          uri = $place.attr('data-not_partial');
          this.fetchExternalPartial($place, uri, options);
        }
        return this;
      };

      Partials.prototype.fetchExternalPartial = function($place, uri, options) {
        var _this = this;
        if (options == null) {
          options = {};
        }
        options = _.defaults(options, {
          onComplete: null
        });
        if (uri.isBlank()) {
          return;
        }
        this.outstandingExternalRequests += 1;
        return $.ajax(uri, {
          dataType: "html",
          complete: function() {
            if ((_this.outstandingExternalRequests -= 1) <= 0) {
              return typeof options.onComplete === "function" ? options.onComplete() : void 0;
            }
          },
          success: function(data) {
            return _this.renderPartial($place, data);
          },
          error: function(jqXHR, textStatus, errorText) {
            return console.log(("Notjs.basics.Partial: Failed to fetch external partial at " + uri + ". ") + ("error: " + errorText + ". status: " + status));
          }
        });
      };

      Partials.prototype.renderPartial = function($place, data) {
        $place.html(data);
        return this.onPartialRendered($place);
      };

      Partials.prototype.onPartialRendered = function($newPartial) {
        var _base;
        return typeof (_base = this.options).onPartialRendered === "function" ? _base.onPartialRendered($newPartial) : void 0;
      };

      Partials.prototype.onPartialsResolved = function(overrideOnPartialsResolved) {
        var _base;
        return (typeof overrideOnPartialsResolved === "function" ? overrideOnPartialsResolved() : void 0) || (typeof (_base = this.options).onPartialsResolved === "function" ? _base.onPartialsResolved() : void 0);
      };

      return Partials;

    })();
  });

}).call(this);


// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Notjs.namespace('basics', function(x) {
    return x.Replicator = (function() {
      /*
          Replicator will clone an element once for each item in a array after calling a callback method and
          insert it immediately after the template element.
      
          Example (HTML):
          <code><pre>
          |  <html>
          |    <body>
          |      Authors List:
          |      <ul id='authorsList'>
          |        <li>
          |          <span class="name">Name</span><span class="genre">Genre</span>
          |        </li>
          |    </body>
          |  </html>
          |  <script>
          |    var authors = [
          |      {name: 'Robert Heinlein', genre: 'Science Fiction'},
          |      {name: 'J. K. Rowling',   genre: 'Fantasy'},
          |      {name: 'Malcom Gladwell', genre: 'Non fiction'}
          |    ];
          |    replicator = new notjs.basics.Replicator('#authorsList')
          |    replicator.replicate(authors, function($newElement, author, index){
          |      $newElement.find('.name').html(author.name);
          |      $newElement.find('.genre').html(author.genre);
          |    });
          |  </script>
          </pre></code>
      
          The example above will generate one li for each of authors array
      */

      Replicator.replicate = function(selector, data, callback) {
        return new Replicator(selector).replicate(data, callback);
        /*
              This class method is convenient, but note that it is effectively one shot only
              as the inner html template is removed.  If you are going to be updating the underlying
              data and want those changes, you should either contruct an instance of
              notjs.basics.replicator or you should save the return value of this method
        
              see replicate instance method for more information
        */

      };

      function Replicator(selector, options) {
        this.selector = selector;
        if (options == null) {
          options = {};
        }
        this.refresh = __bind(this.refresh, this);

        this.replicate = __bind(this.replicate, this);

        this.getTemplate = __bind(this.getTemplate, this);

        this.initialize = __bind(this.initialize, this);

        this.options = _.defaults(options, {
          data: null
        });
        /*
                I wonder if coffee doc will pickup my option defaults?  :( no, but scripts/documentor will! :)
        */

        return this.initialize();
      }

      Replicator.prototype.initialize = function() {
        this.$element = $(this.selector);
        this.getTemplate();
        return this;
      };

      Replicator.prototype.getTemplate = function() {
        /*
                this method returns the a jQuery clone of the template (whatever was in the html of the
                selector passed on construction)
        */
        if (this.$template) {
          return this.$template;
        }
        this.$template = this.$element.clone();
        this.$element.html("");
        return this.$template;
      };

      Replicator.prototype.replicate = function(array, callback) {
        var $newElement, arrayMember, index, _i, _len;
        this.array = array;
        this.callback = callback;
        /*
                this method is passed an <i>array</i> for which <i>callback</i> (also passed) will be called
                once for each element in <i>array</i>.
        
                Callback method:
                    <code><pre>     callback($newElement, arrayMember, index)</pre></code>
                where <code>
                  <b>$newElement</b> - newly created element for this array member
                  <b>arrayMember</b> - the array member
                  <b>index</b> - zero based index of the array member being called for
                </code>
        
                If the callback method returns true,  the $newElement will be appended to the
                selector element.   If the callback method returns false, the newElement
                will <b>not</b> be appended to the selector element
        
                Note that this method can also be called any number of times during the page
                life to "regenerate" the elements replicated into the selector passed to constructor
        
                Implementation note:   avoid text directly in the replicator element.  For example,
                <code>
                |  <div id="replicationTemplate>
                |   Some text to be cloned
                |   <h1>Whatever</h1>
                |   <h2>Wherever</h2>
                |  </div>
                |  <script>
                |    repl = new notjs.basics.replicator('#replicationTemplate')
                |    repl.replicate [1,2,3]
                |  </script>
                </code>
                results in:
                <code>
                |  <div id="replicationTemplate>
                |   <h1>Whatever</h1>
                |   <h2>Wherever</h2>
                |   <h1>Whatever</h1>
                |   <h2>Wherever</h2>
                |   <h1>Whatever</h1>
                |   <h2>Wherever</h2>
                |  </div>
                </code>
                ...without "Some text to be cloned".  To avoid that, put text in an inner element,
                like this:
                <code>
                |  <div id="replicationTemplate>
                |   <span>Some text to be cloned</span>
                |   <h1>Whatever</h1>
                |   <h2>Wherever</h2>
                |  </div>
                </code>
        */

        this.$element.html("");
        for (index = _i = 0, _len = array.length; _i < _len; index = ++_i) {
          arrayMember = array[index];
          $newElement = this.$template.clone();
          if (!callback || callback($newElement, arrayMember, index)) {
            this.$element.append($newElement);
          }
        }
        return this;
      };

      Replicator.prototype.refresh = function() {
        /*
                Called to refresh results of last call to .replicate().  Presumes that the reference to the array
                and the callback method passed to replicate are the same
        */
        if (!((this.array != null) && (this.callback != null))) {
          return;
        }
        return this.replicate(this.array, this.callback);
      };

      return Replicator;

    }).call(this);
  });

}).call(this);


// Generated by CoffeeScript 1.4.0

/*
  javascript String class extensions and monkeys
*/


(function() {

  Notjs.addPrototypeUnlessExists(String, "startsWith", function(anotherString) {
    /*
        returns true if string starts with anotherString
    
        example:
        | "this string".startsWith("this")
        | -> true
    */
    return this.slice(0, anotherString.length) === anotherString;
  });

  Notjs.addPrototypeUnlessExists(String, "endsWith", function(anotherString) {
    /*
        returns true if string ends with anotherString
    
        example:
        | "this string".endsWith("string")
        | -> true
    */
    return this.slice(-anotherString.length) === str;
  });

  Notjs.addPrototypeUnlessExists(String, "isBlank", function() {
    /*
        returns true if this string is blank
    
        examples (all return true):
        | "".isBlank()
        | "   ".isBlank()
        | "\n\r  ".isBlank()
    */
    return this.trim() === "";
  });

  Notjs.addPrototypeUnlessExists(String, "trim", function() {
    /*
        returns copy of this string with white spaces and line end chars removed
    */
    return this.replace(/^\s+|\s+$/g, "");
  });

  Notjs.addPrototypeUnlessExists(String, "elipsize", function(maxLength) {
    /*
        returns a copy of this string truncated to maxLength - 3 and "..." appended
    */
    if (this.length <= maxLength) {
      return this;
    }
    return this.slice(0, maxLength - 3) + '...';
  });

  Notjs.addPrototypeUnlessExists(String, "decamelize", function() {
    /*
        returns a decamelized copy of this string
    
        example:
        | "dropCamelCase".decamelize()
        | => "Drop Camel Case"
    */

    var result;
    result = this.replace(/([A-Z])/g, " $1");
    return result.charAt(0).toUpperCase() + result.slice(1);
  });

  Notjs.addPrototypeUnlessExists(String, "dropCamelize", function() {
    /*
        returns a copy of this string camel cased with first char lower case
    
        example:
        | "Camel Case My Ass".dropCamelize()
        | => "camelCaseMyAss"
    */

    var result;
    result = this.replace(/\s/g, "");
    return result.charAt(0).toLowerCase() + result.slice(1);
  });

}).call(this);


// Generated by CoffeeScript 1.4.0

/*
  Notjs Utility methods
*/


(function() {

  Notjs.deepGet = function(object, pathToAttribute) {
    /*
        gets the value of a nested member of this object.
    
        example:
        <code>
          |  var data = {
          |     sayulita: {
          |       fun: true,
          |       surf: true,
          |       weather: {
          |         high: 90,
          |         low: function(){ return 70; }
          |       }
          |     }
          |   }
          |  Notjs.deepGet(data, 'weather.high')   # will return 90
        </code>
    
        There is no limit to the depth, also functions may be employed anywhere along the path.
        From the former example:
        <code>
          |  Notjs.deepGet(data, 'weather.low')   # will call the function associated with 'low' which returns 70
        </code>
    */

    var current, part, _i, _len, _ref;
    current = object;
    _ref = pathToAttribute.split('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      if (current[part] == null) {
        current = null;
        break;
      }
      current = _.isFunction(current[part]) ? current[part]() : current[part];
    }
    return current;
  };

  Notjs.deepSet = function(object, pathToAttribute, value) {
    /*
        Performs a deep set on the the value of a attributed nested within this object
    
        See Notjs.deepGet() above for examples.  Any value that can be fetched with deepGet
        can be set wih deepSet()
    */

    var current, lastPart, part, parts, _i, _len;
    current = object;
    parts = pathToAttribute.split('.');
    lastPart = _.last(parts);
    for (_i = 0, _len = parts.length; _i < _len; _i++) {
      part = parts[_i];
      if (current[part] == null) {
        current = null;
        break;
      }
      if (part === lastPart) {
        if (_.isFunction(current[part])) {
          return current[part](value);
        } else {
          return current[part] = value;
        }
      }
    }
    return current;
  };

  Notjs.keyCode = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    ESCAPE: 27,
    PAGEUP: 33,
    PAGEDOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    INSERT: 45,
    DELETE: 46
  };

}).call(this);


// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Notjs.namespace('basics.formInputs', function(x) {
    return x.Checkbox = (function(_super) {

      __extends(Checkbox, _super);

      /*
            This FormInput type displays the boolean or truthy value of the data attribute and
            presents an <input type='checkbox'...  type input on edit
      */


      Checkbox.formatForDisplay = function(row, cell, value, columnDef, dataContext) {
        if (value) {
          return "Yes";
        } else {
          return "No";
        }
      };

      function Checkbox(args) {
        this.serializeValue = __bind(this.serializeValue, this);

        this.loadValue = __bind(this.loadValue, this);

        this.initialize = __bind(this.initialize, this);
        Checkbox.__super__.constructor.apply(this, arguments);
      }

      Checkbox.prototype.initialize = function() {
        return this.$input = $(x.Checkbox._renderInput(false, false)).appendTo(this.$element).focus().select();
      };

      Checkbox.prototype.loadValue = function(dataObject) {
        if (this.getDataObjectValue(dataObject)) {
          return this.$input.attr('checked', 'checked');
        } else {
          return this.$input.removeAttr('checked');
        }
      };

      Checkbox.prototype.serializeValue = function() {
        return this.$input.attr('checked') === 'checked';
      };

      Checkbox._renderInput = function(checked, disabled) {
        if (checked == null) {
          checked = false;
        }
        if (disabled == null) {
          disabled = false;
        }
        checked = checked ? "checked='checked'" : "";
        disabled = disabled ? "disabled='disabled'" : "";
        return "<input type='checkbox' " + disabled + " " + checked + "/>";
      };

      return Checkbox;

    }).call(this, Notjs.basics.FormInput);
  });

}).call(this);


// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Notjs.namespace('basics.formInputs', function(x) {
    return x.Text = (function(_super) {

      __extends(Text, _super);

      /*
            This FormInput type displays the string value of the data attribute and
            presents an <input type='text'...  type input on edit
      */


      Text.formatForDisplay = function(row, cell, value, columnDef, dataContext) {
        return value != null ? value.toString() : void 0;
      };

      function Text(args) {
        this.serializeValue = __bind(this.serializeValue, this);

        this.loadValue = __bind(this.loadValue, this);

        this.destroy = __bind(this.destroy, this);

        this.initialize = __bind(this.initialize, this);
        Text.__super__.constructor.apply(this, arguments);
      }

      Text.prototype.initialize = function() {
        var _this = this;
        this.$input = $("<INPUT type=text/>").appendTo(this.$element).on("keydown.nav", function(e) {
          if (e.keyCode === Notjs.keyCode.LEFT || e.keyCode === Notjs.keyCode.RIGHT) {
            return e.stopImmediatePropagation();
          }
        });
        _.defer(function() {
          return _this.$input.focus().select();
        });
        return this.$input;
      };

      Text.prototype.destroy = function() {
        return this.$input.remove();
      };

      Text.prototype.loadValue = function(dataObject) {
        return this.$input.val(this.getDataObjectValue(dataObject));
      };

      Text.prototype.serializeValue = function() {
        return this.$input.val();
      };

      return Text;

    }).call(this, Notjs.basics.FormInput);
  });

}).call(this);


